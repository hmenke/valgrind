/*
   This file is part of Valgrind, a dynamic binary instrumentation
   framework.

   Copyright (C) 2021 Intel Corporation 
      tatyana.a.volnina@intel.com

   This program is free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public License as
   published by the Free Software Foundation; either version 2 of the
   License, or (at your option) any later version.

   This program is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, see <http://www.gnu.org/licenses/>.

   The GNU General Public License is contained in the file COPYING.
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct text_line {
   char name[32];
   int opcode; char prefix[8]; char escape[16];
   char width[8]; char dst_w[8];
   char tuple_type[32];
   char mask[32]; char misc[32]; char exc[8];
   char dst_e[10]; char src1_e[10]; char src2_e[10]; char src3_e[10]; char src4_e[10];
   char dst_t[10]; char src1_t[10]; char src2_t[10]; char src3_t[10]; char src4_t[10];
   char IR_function[32]; char IR[32];
   int multiplier;
   int parameter;
   char asm_function[32];
};
struct text_line data;

char* IRType_to_var (char* IRType) {
   if(!strcmp(IRType, "Ity_V512")) return "V512*";
   if(!strcmp(IRType, "Ity_V256")) return "V256*";
   if(!strcmp(IRType, "Ity_V128")) return "V128*";
   if(!strcmp(IRType, "Ity_F32")) return "Float*";
   if(!strcmp(IRType, "Ity_F64")) return "Double*";
   if(!strcmp(IRType, "Ity_I64")) return "ULong";
   return "UInt";
}

#define NUM_ELEM (26+1)

void clean_data(){
   memset (&data, 0, sizeof(data));
   data.opcode = -1;
   // By default, instruction executes the IR once, so default multiplier is 1
   data.multiplier = 1;
   // The lack of parameter is represented by -1
   data.parameter = -1;
   data.name[0]='\0';
   data.prefix[0]='\0';
   data.escape[0]='\0';
   data.width[0]='\0';
   data.dst_w[0]='\0';
   data.tuple_type[0]='\0';
   data.mask[0]='\0';
   data.misc[0]='\0';
   data.exc[0]='\0';
   data.dst_e[0]='\0';
   data.src1_e[0]='\0';
   data.src2_e[0]='\0';
   data.src3_e[0]='\0';
   data.src4_e[0]='\0';
   data.dst_t[0]='\0';
   data.src1_t[0]='\0';
   data.src2_t[0]='\0';
   data.src3_t[0]='\0';
   data.src4_t[0]='\0';
   data.IR_function[0]='\0';
   data.IR[0]='\0';
   data.asm_function[0]='\0';
}

int main() {
   FILE* master = fopen("master.csv", "r");

   // ensure the opcodes are sorted in the master file - otherwise instruction search fails
   int past_opcode = 0, next_opcode, lineN = 0;
   char line[512];
   char temp[512];
   while (fgets(line, sizeof(line),master)) {
      lineN++;
      int status = sscanf(line, "%*c,0x%x", next_opcode);
      if (status<0) {
         printf("trouble reading opcode at line %d\n", lineN);
         return 0;
      }
      if (next_opcode < past_opcode) {
         printf("line %d is out of order; sort the master file by opcode\n", lineN);
         return 0;
      }
   }
   fclose(master);
   printf("validation passed\n");


   FILE* libvex      = fopen("libvex_ir_AVX512.h", "w");
   FILE* guest_main  = fopen("guest_AVX512.h", "w");
   FILE* host_main   = fopen("host_AVX512.h", "w");
   FILE* host_funcs  = fopen("host_generic_AVX512.h", "w");

   // print header file info and structure definitions
   fprintf(libvex, "#ifdef AVX_512\n"
         "#ifndef __LIBVEX_IR_AVX512_H\n"
         "#define __LIBVEX_IR_AVX512_H\n"
         "\n"
         "/* This file is auto-generated by \"filegen\" script */\n"
         "/* DO NOT MODIFY */\n"
         "\n"
         "#include <libvex_basictypes.h>\n"
         "#pragma GCC diagnostic push\n"
         "#pragma GCC diagnostic ignored \"-Wswitch\"\n"
         "#pragma GCC diagnostic ignored \"-Wdiscarded-qualifiers\"\n"
         "typedef enum {\n"
         "   Iop_FIRST_EVEX=Iop_LAST_NOT_EVEX,\n");
   fprintf(guest_main, "#ifdef AVX_512\n"
         "#ifndef __GUEST_AVX512_H\n"
         "#define __GUEST_AVX512_H\n"
         "\n"
         "/* This file is auto-generated by \"filegen\" script */\n"
         "/* DO NOT MODIFY */\n"
         "\n"
         "#pragma GCC diagnostic push\n"
         "#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n"
         "enum mask_modes { MASK_NONE, MASK_ZERO, MASK_MERGE, MASK_FULL, MASK_MEMORY };\n"
         "enum op_encoding {\n"
         "   _none = 0, _imm8,\n"
         "   _rG, _rV, _rE, _rmE, // vector registers\n"
         "   _iG, _iE, _imE,      // scalar registers\n"
         "   _mG, _mE,            // memory\n"
         "   _kG, _kV, _kE, _kmE, // mask registers\n"
         "   _vm32, _vm64,        // VSIB\n"
         "   _rmode,\n"
         "};\n"
         "\n"
         "struct Ins_data {\n"
         "   const char* name;\n"
         "   short opcode;\n"
         "   Long pfx;\n"
         "   Escape esc;\n"
         "   enum encoded_w     src_w;  // Encoded in EVEX\n"
         "   enum operand_width dst_w;  // Instruction-specific\n"
         "\n"
         "   IRTemp (*opFn)(IRTemp, IRTemp, UChar); // Alternate to irop\n"
         "   IROp_EVEX irop;                 // Iop_LAST for special cases\n"
         "   Int multiplier;                 // How many times to call IR/function\n"
         "   UInt parameter;                 // Optional parameter to pass to IR/function\n"
         "\n"
         "   enum TupleType type;\n"
         "   enum mask_modes mask;\n"
         "   const char* misc;    // er, sae, is4, imz2 etc\n"
         "   enum exception_class exc;"
         "\n"
         "   // normally the operands follow Intel syntax: dst, src1, src2,..\n"
         "   // if dst is used as source OR is a mask register, it must be listed as 1st source\n"
         "   // if IR benefits from a change in source order, it is changed\n"
         "   const enum op_encoding args[5];\n"
         "   const IRType arg_type[5];\n"
         "};\n"
         "\n"
         "static struct Ins_data INS_ARR[] = {\n"
         "   /* name | opcode | prefix | escape | width | IR or function | mult | param | tuple type | mask type | misc | exc | operands (Intel syntax) */\n"
         );
   fprintf(host_main, "#ifdef AVX_512\n"
         "#ifndef __HOST_AVX512_H\n"
         "#define __HOST_AVX512_H\n"
         "\n"
         "/* This file is auto-generated by \"filegen\" script */\n"
         "/* DO NOT MODIFY */\n"
         "\n"
         "#include <host_generic_simd64.h>\n"
         "#include <host_amd64_defs.h>\n"
         "#include <host_generic_AVX512.h>\n"
         "\n"
         "typedef struct {\n"
         "   char* name;\n"
         "   const void* function_call;\n"
         "   const IRType operands[5]; // in most cases, Intel syntax: dst, src1, src2,..\n"
         "}\n"
         "Iop_data;\n"
         "\n"
         "#define INDEX(ir) ((ir)-Iop_FIRST_EVEX)\n"
         "#pragma GCC diagnostic ignored \"-Wdiscarded-qualifiers\"\n"
         "static const Iop_data IOPS_ARR[] = {\n"
         "   /*     OPCODE IRs          { text name | function | operands (Intel syntax) } */\n"
         );
   fprintf(host_funcs, "#ifdef AVX_512\n"
         "#ifndef __VEX_HOST_GENERIC_AVX512_H\n"
         "#define __VEX_HOST_GENERIC_AVX512_H\n"
         "\n"
         "/* This file is auto-generated by \"filegen\" script */\n"
         "/* DO NOT MODIFY */\n"
         "\n"
         "#pragma GCC diagnostic push\n"
         "#pragma GCC diagnostic ignored \"-Wattributes\"\n"
         "#include <libvex_basictypes.h>\n"
         );

   // parse and write the data
   // for simplicity, ignore the duplicates for now and remove them later with a shell script

   master = fopen("master.csv", "r");
   // skip a couple of header lines
   fgets(line, sizeof(line),master);
   fgets(line, sizeof(line),master);

   char* line_elems[NUM_ELEM];
   while (fgets(line, sizeof(line), master)) {
      clean_data();

      int count = 0;
      char *p = line;
      for( int i = 0; i < NUM_ELEM; i++) {
         if(*p != '\0')
            line_elems[count++] = p;
         else {
            line_elems[count] = 0;
            break;
         }
         while(*p != '\0' && *p != ',' && *p != '\n')
            p++;
         *p++ = '\0';
      }
      int k = 0;
      strcpy(data.name,   line_elems[k]);
      sscanf(line_elems[++k], "0x%x", &data.opcode);
      k += 1; // skip VEX/EVEX prefix for now
      strcpy(data.prefix, line_elems[++k]);
      strcpy(data.escape, line_elems[++k]);
      strcpy(data.width,  line_elems[++k]);
      strcpy(data.dst_w,  line_elems[++k]);
      strcpy(data.tuple_type, line_elems[++k]);
      strcpy(data.mask,   line_elems[++k]);
      strcpy(data.misc,   line_elems[++k]);
      strcpy(data.exc,    line_elems[++k]);
      strcpy(data.dst_e,  line_elems[++k]);
      strcpy(data.src1_e, line_elems[++k]);
      strcpy(data.src2_e, line_elems[++k]);
      strcpy(data.src3_e, line_elems[++k]);
      strcpy(data.src4_e, line_elems[++k]);
      strcpy(data.dst_t,  line_elems[++k]);
      strcpy(data.src1_t, line_elems[++k]);
      strcpy(data.src2_t, line_elems[++k]);
      strcpy(data.src3_t, line_elems[++k]);
      strcpy(data.src4_t, line_elems[++k]);
      strcpy(data.IR_function, line_elems[++k]);
      strcpy(data.IR,     line_elems[++k]);

      data.multiplier = atoi(line_elems[++k]);
      if (data.multiplier == 0)
         data.multiplier = 1;

      k += 1;
      if (line_elems[k][0] != '\0') 
         data.parameter = atoi(line_elems[k]);

      strcpy(data.asm_function, line_elems[++k]);


      // Start filling C structures

      // If an entry describes a completely new IR, add it to IR enums
      if (strcmp(data.IR, "Iop_INVALID") &&
            strcmp(data.asm_function, "LEGACY") && strcmp(data.asm_function, "LEGACY_IR"))
      {
         fprintf(libvex, "\t%s,\n", data.IR);
      }

      // If an entry describes a guest instruction, add it to guest instructions structures
      if (data.name[0] != '\0')
      {
         fprintf(guest_main, "\t{\"%s\",\t0x%x, %s, %s, %s, ",
               data.name, data.opcode, data.prefix, data.escape, data.width);
            
         if (data.dst_w[0]=='\0')
            fprintf(guest_main, "0, ");
         else fprintf(guest_main, "%s, ", data.dst_w);
         
         fprintf(guest_main, "%s, %s, %d, %d, %s, %s, ",
            data.IR_function, data.IR, data.multiplier, data.parameter, data.tuple_type, data.mask);
         
         if (data.misc[0]=='\0')
            fprintf(guest_main, "NULL, ");
         else fprintf(guest_main, "\"%s\", ", data.misc);
         
         if (data.exc[0]=='\0')
            fprintf(guest_main, "EXC_UNDEF, ");
         else fprintf(guest_main, "%s, ", data.exc);
         
         fprintf(guest_main, " {");
         if (data.dst_e[0]  != '\0') fprintf(guest_main, "_%s", data.dst_e);
         if (data.src1_e[0] != '\0') fprintf(guest_main, ",_%s", data.src1_e);
         if (data.src2_e[0] != '\0') fprintf(guest_main, ",_%s", data.src2_e);
         if (data.src3_e[0] != '\0') fprintf(guest_main, ",_%s", data.src3_e);
         if (data.src4_e[0] != '\0') fprintf(guest_main, ",_%s", data.src4_e);
         fprintf(guest_main, "}, {");
         if (data.dst_t[0]  != '\0') fprintf(guest_main, "%s", data.dst_t);
         if (data.src1_t[0] != '\0') fprintf(guest_main, ",%s", data.src1_t);
         if (data.src2_t[0] != '\0') fprintf(guest_main, ",%s", data.src2_t);
         if (data.src3_t[0] != '\0') fprintf(guest_main, ",%s", data.src3_t);
         if (data.src4_t[0] != '\0') fprintf(guest_main, ",%s", data.src4_t);
         fprintf(guest_main, "}},\n");
      }

      // If we declare a new IR to assembly translation, add it to host and Memcheck files
      // Skip entries with multipliers or partial xmm usage:
      // those split arguments before getting to the host, so we don't know argument types for those IRs
      // Add such IRs to the end of the file without matching guest assembly and multiplier/xmm
      if (strcmp(data.IR, "Iop_INVALID") && strcmp(data.asm_function, "LEGACY") &&
            (data.multiplier == 1))
      {
         // Add a translation of IR to amd64 assembly to IR structures

         // Limitation: cannot introduce a new translation of existent IR this way
         if (strcmp(data.asm_function, "LEGACY_IR")) {
            fprintf(host_main, "\t[ INDEX (%s)]\t= {\"%s\", ", data.IR, data.IR);
            if (!strcmp(data.asm_function, "DEFAULT"))
               // by default, IopSmth calls a helper function named h_IopSmth
               fprintf(host_main, "h_%s,", data.IR);
            else fprintf(host_main, "NULL,");
            fprintf(host_main, " {%s,%s", data.dst_t, data.src1_t);
            if (data.src2_t[0] != '\0') fprintf(host_main, ",%s", data.src2_t);
            if (data.src3_t[0] != '\0') fprintf(host_main, ",%s", data.src3_t);
            if (data.src4_t[0] != '\0') fprintf(host_main, ",%s", data.src4_t);
            if (data.parameter != -1) fprintf(host_main, ",Ity_I8");
            fprintf(host_main, "}},\n");
         }

         if (strcmp(data.asm_function, "NULL"))
         {
            // declare the new IR-to-assembly helper function
            int num_args = 2; //src and dst
            if (data.src2_t[0] != '\0') num_args++;
            if (data.src3_t[0] != '\0') num_args++;
            if (data.src4_t[0] != '\0') num_args++;
            if (data.parameter != -1) num_args++;
            if (num_args >= 4 && (!strcmp( data.dst_t, data.src1_t)))
            {
               // we might be unable to place all args on stack
               // but the 1st source and dst match types so they can share a pointer
               fprintf(host_funcs, "VEX_REGPARM(%d) void h_%s (%s", num_args-1, data.IR, IRType_to_var(data.dst_t));
               // Normally, everything except integer operands are passed through reference
               // Destination must be passed through reference even in integer case
               if (!strncmp(data.dst_t, "Ity_I", strlen("Ity_I")))
                  fprintf(host_funcs,"*");
            } else {
               //put everything on stack
               fprintf(host_funcs, "VEX_REGPARM(%d) void h_%s (%s", num_args, data.IR, IRType_to_var(data.dst_t));
               if (!strncmp(data.dst_t, "Ity_I", strlen("Ity_I")))
                  fprintf(host_funcs,"*");
               if (data.src1_t) fprintf(host_funcs, ",%s", IRType_to_var(data.src1_t));
            }
            if (data.src2_t[0] != '\0') fprintf(host_funcs, ",%s", IRType_to_var(data.src2_t));
            if (data.src3_t[0] != '\0') fprintf(host_funcs, ",%s", IRType_to_var(data.src3_t));
            if (data.src4_t[0] != '\0') fprintf(host_funcs, ",%s", IRType_to_var(data.src4_t));
            if (data.parameter != -1) fprintf(host_funcs, ",UInt");
            fprintf(host_funcs, ");\n");
         }
      }
   }

   // print closing braces and close files
   fprintf(libvex, "\tIop_LAST,      /* must be the last enumerator */\n"
         "} IROp_EVEX;\n"
         "#pragma GCC diagnostic pop\n"
         "#endif /* ndef __LIBVEX_IR_AVX512_H */\n"
         "#endif /* ndef AVX_512*/\n");
   fprintf(guest_main, "};\n"
         "#pragma GCC diagnostic pop\n"
         "#endif /* ndef __GUEST_AVX512_H */\n"
         "#endif /* ndef AVX_512*/\n");
   fprintf(host_main, "};\n"
         "#pragma GCC diagnostic pop\n"
         "#endif /* ndef __HOST_AVX512_H */\n"
         "#endif /* ndef AVX_512*/\n");
   fprintf(host_funcs, "\n"
         "#pragma GCC diagnostic pop\n"
         "#endif /* ndef __VEX_HOST_GENERIC_AVX512_H */\n"
         "#endif /* ndef AVX_512*/\n");

   fclose(master);
   fclose(libvex);
   fclose(guest_main);
   fclose(host_main);
   fclose(host_funcs);
}
